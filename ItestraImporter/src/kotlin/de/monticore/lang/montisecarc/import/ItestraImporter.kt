package de.monticore.lang.montisecarc.importimport com.google.gson.Gsonimport com.google.gson.reflect.TypeTokenimport de.monticore.lang.montisecarc.import.data.*import java.io.Fileimport java.io.InputStream/** * Copyright 2016 Thomas Buning * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */class ItestraImporter {    private var importedQueryResults: List<Result> = emptyList()    private var outPutFolderPath: String = "/"    private var packageIdentifier: String = "demo"    constructor(potentialImportFile: File, output: String, packageIdentifier: String) {        potentialImportFile.bufferedReader().use {            val queryResults: List<QueryResult> = Gson().fromJson(it, object : TypeToken<List<QueryResult>>() {            }.type)            importedQueryResults = queryResults.filter { it.query != "BusinessUnit" }.flatMap(QueryResult::results)        }        outPutFolderPath = output        this.packageIdentifier = packageIdentifier    }    constructor(potentialImportString: String, output: String, packageIdentifier: String) {        val queryResults: List<QueryResult> = Gson().fromJson(potentialImportString, object : TypeToken<List<QueryResult>>() {        }.type)        outPutFolderPath = output        this.packageIdentifier = packageIdentifier        importedQueryResults = queryResults.filter { it.query != "BusinessUnit" }.flatMap(QueryResult::results)    }    constructor(inputStream: InputStream, output: String, packageIdentifier: String) {        inputStream.bufferedReader().use {            val queryResults: List<QueryResult> = Gson().fromJson(it, object : TypeToken<List<QueryResult>>() {            }.type)            importedQueryResults = queryResults.filter { it.query != "BusinessUnit" }.flatMap(QueryResult::results)        }        outPutFolderPath = output        this.packageIdentifier = packageIdentifier    }    private fun transform(results: List<Result>): List<Component> {        val infrastructureMapping = results                .filter { (it.businessObject != null || it.informationSystemRelease != null) && it.infrastructureElements != null }                .map {                    var startObjectId: String? = null                    if (it.informationSystemRelease != null) {                        startObjectId = it.informationSystemRelease.first().id                    } else if (it.businessObject != null) {                        startObjectId = it.businessObject.first().id                    }                    if (it.infrastructureElements != null && startObjectId != null) {                        val stopObjectId = it.infrastructureElements.first().id                        Pair(startObjectId, stopObjectId)                    } else {                        null                    }                }.filter { it != null }.requireNoNulls()        val lookupTable = mutableMapOf<String, Component>()        results.forEach {            val component = it.toComponent()            lookupTable.put(component.id, component)        }        results.filter { it.parents != null && it.parents.isNotEmpty() }.forEach {            val id = it.ids.first().toString()            lookupTable[id]?.parent = lookupTable[it.parents!!.first().id]        }        results.filter { it.parents != null && it.parents.isNotEmpty() }.forEach {            val id = it.ids.first().toString()            val component = lookupTable[id]            if (component != null) {                //Add Children                val parentId = it.parents!!.first().id                val list = lookupTable[parentId]?.children?.plus(component)                if (list != null) {                    lookupTable[parentId]?.children = list                }            }        }        results.filter { it.parents != null && it.parents.isNotEmpty() }.forEach {            val id = it.ids.first().toString()            val component = lookupTable[id]            if (component != null) {                if (it.baseComponents != null && it.baseComponents.isNotEmpty()) {                    it.baseComponents                            .map { lookupTable[it.id] }                            .filter { it != null }                            .requireNoNulls()                            .forEach {                                val ancestor = component.findCommonAncestor(it)                                if (ancestor != null) {                                    val newList = lookupTable[ancestor.id]?.connections?.plus(Connection(component, it))                                    if (newList != null) {                                        lookupTable[ancestor.id]?.connections = newList                                    }                                } else {                                    val newList = lookupTable[component.id]?.connections?.plus(Connection(component, it))                                    if (newList != null) {                                        lookupTable[component.id]?.connections = newList                                    }                                }                            }                }            }        }        results.filter { it.infrastructureElements != null }.map { env ->            if (env.infrastructureElements != null && env.infrastructureElements.isNotEmpty()) {                val trustLevels = env.infrastructureElements.map {                    lookupTable[it.id]?.trustLevel                }.filter { it != null }.requireNoNulls().sorted()                if (trustLevels.isNotEmpty()) {                    lookupTable[env.ids.first().toString()]?.trustLevel = trustLevels.first()                }            }        }        infrastructureMapping.forEach {            /**             * Follow Infrastructure Element To a Parent that has a TrustLevel             */            var foundTrustLevel = lookupTable[it.second]?.trustLevel            var foundParent = lookupTable[it.second]?.parent            while (foundTrustLevel == null && foundParent != null) {                foundParent = foundParent.parent                foundTrustLevel = foundParent?.trustLevel            }            // Default TrustLevel is 3            lookupTable[it.first]?.trustLevel = foundTrustLevel ?: 3        }        lookupTable                .map { it.value }                .filter { it.parent != null && it.trustLevel != null }                .forEach {                    val childTrustLevel = it.trustLevel!!                    var parent = it.parent                    var parentTrustLevel = it.parent!!.trustLevel                    while (parent != null && parentTrustLevel == null) {                        parent = parent.parent                        parentTrustLevel = parent?.trustLevel                    }                    it.trustLevel = childTrustLevel - (parentTrustLevel ?: 0)                    // Delete TrustLevel 0 (no change) for better readability                    if (it.trustLevel == 0) {                        it.trustLevel = null                    }                }        return lookupTable.filter { it.value.parent == null }.map { it.value }    }    private fun getChildModelsRecursive(children: List<Component>, inPortNeededIds: List<String>, outPortNeededIds: List<String>): List<Pair<String, List<String>>> {        return children.map { child ->            val map = mutableMapOf<String, Any>()            map.put("componentName", child.typeName)            map.put("componentInstanceName", child.instanceName)            if (child.trustLevel != null) {                map.put("trustlevel", child.trustLevel.toString())            }            val list = getChildModelsRecursive(child.children, inPortNeededIds, outPortNeededIds)            map.put("subcomponents", list.map { it.first })            if (inPortNeededIds.contains(child.id)) {                map.put("inNeeded", "")            }            if (outPortNeededIds.contains(child.id)) {                map.put("outNeeded", "")            }            var imports = emptyList<String>()            if (child.connections.isNotEmpty()) {                val connections = child.connections.map {                    var from = child.getPath(it.from)                    var to = child.getPath(it.to)                    // Create Instance                    val mutableMap = mutableMapOf<String, String>()                    if (to != null) {                        if (!from.isNullOrEmpty()) {                            from += "."                        }                        if (!to.isNullOrEmpty()) {                            to += "."                        }                        mutableMap.put("from", from ?: "")                        mutableMap.put("to", to)                    } else {                        mutableMap.put("from", "")                        mutableMap.put("to", "${it.to.instanceName}.")                    }                    mutableMap                }                val instances = child.connections.filter { child.getPath(it.to) == null }.map {                    val mutableMap = mutableMapOf<String, String>()                    mutableMap.put("type", it.to.typeName)                    mutableMap.put("name", it.to.instanceName)                    mutableMap.put("connector", "[outDummy -> inDummy]")                    Pair(mutableMap, "$packageIdentifier.${it.to.typeName}")                }                map.put("instances", instances.map { it.first })                map.put("connections", connections)                imports = imports.plus(instances.map { it.second })            }            Pair(FreeMarker().generateModelOutput("ToMSA/MSAComponent.ftl", map).removeUnnecessaryFreeMarkerCharacters(), imports)        }    }    private fun getModelFor(env: Component, inPortNeededIds: List<String>, outPortNeededIds: List<String>): String {        val map = mutableMapOf<String, Any>()        map.put("componentName", env.typeName)        if (env.trustLevel != null) {            map.put("trustlevel", env.trustLevel as Int)        }        val childModels: List<Pair<String, List<String>>> = getChildModelsRecursive(env.children, inPortNeededIds, outPortNeededIds)        map.put("subcomponents", childModels.map { it.first })        if (inPortNeededIds.contains(env.id)) {            map.put("inNeeded", "")        }        if (outPortNeededIds.contains(env.id)) {            map.put("outNeeded", "")        }        map.put("packageName", packageIdentifier)        if (env.connections.isNotEmpty()) {            val connections = env.connections.map {                var from = env.getPath(it.from)                var to = env.getPath(it.to)                // Create Instance                val mutableMap = mutableMapOf<String, String>()                if (to != null) {                    if (!from.isNullOrEmpty()) {                        from += "."                    }                    if (!to.isNullOrEmpty()) {                        to += "."                    }                    mutableMap.put("from", from ?: "")                    mutableMap.put("to", to)                } else {                    mutableMap.put("from", "")                    mutableMap.put("to", "${it.to.instanceName}.")                }                mutableMap            }            val instances = env.connections.filter { env.getPath(it.to) == null }.map {                val mutableMap = mutableMapOf<String, String>()                mutableMap.put("type", it.to.typeName)                mutableMap.put("name", it.to.instanceName)                mutableMap            }            map.put("connections", connections)            map.put("instances", instances)        }        val imports = env.connections.filter { env.getPath(it.to) == null }.map { "$packageIdentifier.${it.to.typeName}" }        val childImports = childModels.flatMap { it.second }        map.put("imports", imports.union(childImports))        return FreeMarker().generateModelOutput("ToMSA/MSAEnvComponent.ftl", map).removeUnnecessaryFreeMarkerCharacters()    }    private fun String.removeUnnecessaryFreeMarkerCharacters() = Regex("[\r\n]+").replace(this.trim(), "\r\n")    fun toMSAFiles(deleteInfrastructureElements: Boolean = true) {        val results = importedQueryResults        val usedNodeIds = results.flatMap {            it.baseComponents.orEmpty().map(Node::id).union(it.parents.orEmpty().map(Node::id))        }.toSet()        val infrastructureIds = results.filter { it.infrastructureElements != null }.flatMap {            it.infrastructureElements!!.map(Node::id)        }.toSet()        //results = results.filter { usedNodeIds.contains(it.ids.first().toString()) }.filter { deleteInfrastructureElements && !infrastructureIds.contains(it.ids.first().toString()) }        val inPortNeededIds = results.filter { it.baseComponents != null && it.baseComponents.isNotEmpty() }.flatMap {            it.baseComponents!!.map(Node::id)        }        val outPortNeededIds = results.filter { it.baseComponents != null && it.baseComponents.isNotEmpty() }.map {            it.ids.first().toString()        }        val list = transform(results)        list                .filter { usedNodeIds.contains(it.id) }                .filter { deleteInfrastructureElements && !infrastructureIds.contains(it.id) }                .forEach {                    /**                     * Create Environment MSA Files                     * One File per Environment Component                     */                    val modelFor = getModelFor(it, inPortNeededIds, outPortNeededIds)                    val file = File("$outPutFolderPath/${it.typeName}.secarc")                    file.writeText(modelFor)                }    }}