import com.google.gson.Gsonimport com.google.gson.reflect.TypeTokenimport de.monticore.lang.montisecarc.data.Nodeimport de.monticore.lang.montisecarc.data.QueryResultimport de.monticore.lang.montisecarc.data.Resultimport de.monticore.lang.montisecarc.data.toComponentimport de.monticore.lang.montisecarc.import.data.Componentimport de.monticore.lang.montisecarc.import.data.Connectionimport de.monticore.lang.montisecarc.import.data.Importerimport de.monticore.lang.montisecarc.import.data.findCommonAncestorimport java.io.InputStream/** * Copyright 2016 Thomas Buning * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */class IteraplanImporter : Importer() {    private fun transform(results: List<Result>): List<Component> {        val infrastructureMapping = results                .filter { (it.businessObject != null || it.informationSystemRelease != null) && it.infrastructureElements != null }                .map {                    var startObjectId: String? = null                    if (it.informationSystemRelease != null) {                        startObjectId = it.informationSystemRelease.first().id                    } else if (it.businessObject != null) {                        startObjectId = it.businessObject.first().id                    }                    if (it.infrastructureElements != null && startObjectId != null) {                        val stopObjectId = it.infrastructureElements.first().id                        Pair(startObjectId, stopObjectId)                    } else {                        null                    }                }.filter { it != null }.requireNoNulls()        val lookupTable = mutableMapOf<String, Component>()        results.forEach {            val component = it.toComponent()            lookupTable.put(component.id, component)        }        results.filter { it.parents != null && it.parents.isNotEmpty() }.forEach {            val id = it.ids.first().toString()            lookupTable[id]?.parent = lookupTable[it.parents!!.first().id]        }        results.filter { it.parents != null && it.parents.isNotEmpty() }.forEach {            val id = it.ids.first().toString()            val component = lookupTable[id]            if (component != null) {                //Add Children                val parentId = it.parents!!.first().id                val list = lookupTable[parentId]?.children?.plus(component)                if (list != null) {                    lookupTable[parentId]?.children = list                }            }        }        results.filter { it.parents != null && it.parents.isNotEmpty() }.forEach {            val id = it.ids.first().toString()            val component = lookupTable[id]            if (component != null) {                if (it.baseComponents != null && it.baseComponents.isNotEmpty()) {                    it.baseComponents                            .map { lookupTable[it.id] }                            .filter { it != null }                            .requireNoNulls()                            .forEach {                                val ancestor = component.findCommonAncestor(it)                                if (ancestor != null) {                                    val newList = lookupTable[ancestor.id]?.connections?.plus(Connection(component, it))                                    if (newList != null) {                                        lookupTable[ancestor.id]?.connections = newList                                    }                                } else {                                    val newList = lookupTable[component.id]?.connections?.plus(Connection(component, it))                                    if (newList != null) {                                        lookupTable[component.id]?.connections = newList                                    }                                }                            }                }            }        }        results.filter { it.infrastructureElements != null }.map { (ids, _, _, _, _, infrastructureElements) ->            if (infrastructureElements != null && infrastructureElements.isNotEmpty()) {                val trustLevels = infrastructureElements.map {                    lookupTable[it.id]?.trustLevel                }.filter { it != null }.requireNoNulls().sorted()                if (trustLevels.isNotEmpty()) {                    lookupTable[ids.first().toString()]?.trustLevel = trustLevels.first()                }            }        }        infrastructureMapping.forEach {            /**             * Follow Infrastructure Element To a Parent that has a TrustLevel             */            var foundTrustLevel = lookupTable[it.second]?.trustLevel            var foundParent = lookupTable[it.second]?.parent            while (foundTrustLevel == null && foundParent != null) {                foundParent = foundParent.parent                foundTrustLevel = foundParent?.trustLevel            }            // Default TrustLevel is 3            lookupTable[it.first]?.trustLevel = foundTrustLevel ?: 3        }        lookupTable                .map { it.value }                .filter { it.parent != null && it.trustLevel != null }                .forEach {                    val childTrustLevel = it.trustLevel!!                    var parent = it.parent                    var parentTrustLevel = it.parent!!.trustLevel                    while (parent != null && parentTrustLevel == null) {                        parent = parent.parent                        parentTrustLevel = parent?.trustLevel                    }                    it.trustLevel = childTrustLevel - (parentTrustLevel ?: 0)                    // Delete TrustLevel 0 (no change) for better readability                    if (it.trustLevel == 0) {                        it.trustLevel = null                    }                }        return lookupTable.filter { it.value.parent == null }.map { it.value }    }    override fun toComponents(inputStream: InputStream, output: String, packageIdentifier: String): Triple<List<Component>, List<String>, List<String>> {        var importedQueryResults: List<Result> = emptyList()        inputStream.bufferedReader().use {            val queryResults: List<QueryResult> = Gson().fromJson(it, object : TypeToken<List<QueryResult>>() {            }.type)            importedQueryResults = queryResults.filter { it.query != "BusinessUnit" }.flatMap(QueryResult::results)        }        val results = importedQueryResults        val usedNodeIds = results.flatMap {            it.baseComponents.orEmpty().map(Node::id).union(it.parents.orEmpty().map(Node::id))        }.toSet()        val infrastructureIds = results.filter { it.infrastructureElements != null }.flatMap {            it.infrastructureElements!!.map(Node::id)        }.toSet()        //results = results.filter { usedNodeIds.contains(it.ids.first().toString()) }.filter { deleteInfrastructureElements && !infrastructureIds.contains(it.ids.first().toString()) }        val inPortNeededIds = results.filter { it.baseComponents != null && it.baseComponents.isNotEmpty() }.flatMap {            it.baseComponents!!.map(Node::id)        }        val outPortNeededIds = results.filter { it.baseComponents != null && it.baseComponents.isNotEmpty() }.map {            it.ids.first().toString()        }        val list = transform(results)        return Triple(list                .filter { usedNodeIds.contains(it.id) }                .filter { !infrastructureIds.contains(it.id) },                inPortNeededIds,                outPortNeededIds)    }}